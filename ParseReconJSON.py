'''
WiFi Pineapple AP - Reconnaissance Output JSON Parser

This script was written for the express purpose of organizing the reconnaissance
data generated by a Hak5 WiFi Pineapple. It accepts the recon_data JSON file produced
by the Pineapple and parses the data into a hierarchry of dictionaries and lists.
It then provides options for in-depth analysis of the data.

 Author: Collin Hicks
         University of Arizona
         December 4, 2020
         v. 1.0
'''

# Import necessary libraries
from os import path
from sys import argv, platform
from time import ctime
from urllib import request


class ParseReconJSON():
    ''' Accepts a JSON File and organizes the data into a dictionary '''
    def __init__(self, filepath):
        # Initialize the object variables
        self.masterDict = {}
        
        self.apManufSummary = {}
        self.clientManufSummary = {}
        
        # Initialize the OUI lookup dictionary
        self.ouiLookup = {}
        self.ouiResolved = False
        
        # Attempt to open the file; Quit on error
        try:
            self.jsonfile = open(filepath,'r')
        except:
            print("Error opening file\nExiting...")
            quit()
            
        # Burn off the first 2 lines; they're useless
        self.jsonfile.readline()
        self.jsonfile.readline()
        
        # Start the process by calling __pullDictionary on masterDict
        print(f"Extracting data from {filepath}...")
        self.__pullDictionary(self.masterDict)
        print("Extraction complete")
        
        self.jsonfile.close()
        

    def __extractKeyVal(self,line):
        ''' This function extracts a key and value from a line of text '''
        # Remove the useless characters
        lLine = line.strip(" ,\n")
        
        # Split the line into its key & value components
        pos = lLine.rfind(": ")
        lkey = lLine[1:(pos - 1)]
        lval = lLine[(pos + 2):]
        lval = lval.strip('"')
        
        # Convert lval to a number, if applicable
        try:
            lval = int(lval)
        except:
            pass
        
        # Convert epoch time to human readable
        if lkey == "last_seen":
            lval = ctime(lval)
        
        # Clean up useless info
        if lval == "[]":
            lval = ""
        
        # This informs __pullDictionary that it's at the end of a dictionary
        if lLine == "}" or lLine == "},":
            lkey = None
            lval = None
            
        return (lkey, lval)
    
        
    def __pullDictionary(self,diction):
        ''' Recursively compiles JSON data into a hierarchry of dictionaries '''
        curKey = ""
        curVal = ""
        
        while True:
            # Read a line and feed it to __extractKeyVal
            curLine = self.jsonfile.readline()
            curKey, curVal = self.__extractKeyVal(curLine)
            
            # Found a new dictionary
            if curVal == "{":
                # Initialize the dictionary then call __pullDictionary on the new value
                diction[curKey] = {}
                self.__pullDictionary(diction[curKey])
            
            # Found a list
            elif curVal == "[":
                # Initialize the list, then __pullList to populate it
                diction[curKey] = []
                self.__pullList(diction[curKey])
                
            # Found the end of the dictionary; break the loop
            elif curKey == None:
                break
            
            # Default: Save key : value pair
            else:
                diction[curKey] = curVal
                
    
    def __pullList(self, listUnit):
        ''' pulls data to a list instead of a dictionary '''
        curLine = self.jsonfile.readline()
        
        # Keep going until finding the end of the list
        while curLine.strip() != "]":
            # Strip the useless characters then append the value
            lLine = curLine.strip(' ",:\n')
            listUnit.append(lLine)
            
            # Get the next line
            curLine = self.jsonfile.readline()

            
    def __getOUI(self, MAC):
        ''' tests a MAC address against the OUI dictionary '''
        
        # Remove colons from address to work with the OUI dictionary
        test = MAC.replace(":","")
        
        # Remove characters from the right until finding a match or exiting the loop
        while len(test) > 0:
            try:
                oui = self.ouiLookup[test]
                return oui
            except KeyError:
                test = test[:-1]
        
        # No match found in OUI dictionary
        return "Not found"                

    def __relatedMAC(self,firstMAC,secondMAC):
        ''' Determines if 2 MAC addresses are likely from the same piece of hardware '''
        firstMAC = firstMAC.replace(":","")
        secondMAC = secondMAC.replace(":","")
        
        # These will raise an error if the MAC isn't a valid hexadecimal number
        # This is intentionally left outside of a try/except block so error handling
        # can be done elsewhere.
        firstMAC = int(firstMAC,16)
        secondMAC = int(secondMAC,16)
        
        if abs(firstMAC - secondMAC) <= 5:
            return True
        else:
            return False    


    def ListOutOfRange(self):
        ''' Prints out the list of Out-of-Range Clients and their parent APs '''
        print()
        
        # Early return if no OOR clients exist
        try:
            test = self.masterDict['outOfRangeClients']
        except KeyError:
            print("There are no out-of-range clients")
            return
        
        # Build the table
        if self.ouiResolved:
            # Include manufacturer info
            ooRTable = [('Client MAC', 'Client Manufacturer','Parent Access Point','Access Point Manufacturer')]
            for client, info in self.masterDict['outOfRangeClients'].items():
                ooRTable.append((client,info['Manufacturer'],info['bssid'],info['apManufacturer']))
                
        else:
            # Just a list of MAC addresses
            ooRTable = [('Client MAC', 'Parent Access Point')]
            for client, ap in self.masterDict['outOfRangeClients'].items():
                ooRTable.append((client,ap))
        
        # Calculate column widths
        colWidths = GetColumnWidths(ooRTable)
        
        # Print the table headers (centered)
        for item in range(len(ooRTable[0])):
            print(str(ooRTable[0][item]).center(colWidths[item]), end='  ')
        print("\n")
        
        # Print out the rest of the table
        for row in range(1, len(ooRTable)):
            for column in range(len(ooRTable[0])):
                print("%-*s  " % (colWidths[column],str(ooRTable[row][column])), end="")
            print()        


    def ListUnassociated(self):
        ''' Prints out the unassociated clients '''
        print()
        
        # Early return if no unassociated clients exist
        try:
            test = self.masterDict['unassociatedClients']
            test.sort()
        except KeyError:
            print("There are no unassociated clients")
            return
        
        # Since unassociatedClients is already a list, printing is a little simpler
        if self.ouiResolved:
            # Calculate column widths
            colWidths = GetColumnWidths(self.masterDict['unassociatedClients'])
            
            # Print headers (centered)
            print("Client".center(colWidths[0]) + "  " + "Manufacturer".center(colWidths[1]) + "\n")
            
            # Print the rest of the table
            for eachClient in self.masterDict['unassociatedClients']:
                print("%-*s  %-*s" % (colWidths[0],eachClient[0],colWidths[1],eachClient[1]))
        else:
            # Even easier, just print out a header followed by the list
            print("Client".center(17) + "\n")
            for eachClient in self.masterDict['unassociatedClients']:
                print(eachClient)


    def PrintAssociations(self):
        ''' Prints out info, organizing clients beneath their associated access points '''
        
        # First line is the table headers
        if self.ouiResolved:
            orgTable = [('SSID','MAC','Manufacturer','Last Seen','Signal Strength','Encryption','Channel','WPS')]
        else:
            orgTable = [('SSID','MAC','Last Seen','Signal Strength','Encryption','Channel','WPS')]
        
        # Store the keys (AP MACs) to a list to be sorted
        apList = list(self.masterDict['aps'].keys())
        apList.sort()
        
        # Iterate through the APs to build the table
        for key in apList:
            val = self.masterDict['aps'][key]
            
            # Only include networks with associated clients
            if val['clients']:

                if val['ssid']:
                    holdSSID = val['ssid']
                else:
                    holdSSID = "Hidden"
                    
                if self.ouiResolved:
                    orgTable.append((holdSSID,key,val['Manufacturer'],val['last_seen'],val['signal'],val['encryption'],val['channel'],str(bool(val['wps']))))
                else:
                    orgTable.append((holdSSID,key,val['last_seen'],val['signal'],val['encryption'],val['channel'],str(bool(val['wps']))))
                
                for clientKey, clientVal in val['clients'].items():
                    if self.ouiResolved:
                        orgTable.append(('',clientKey,clientVal['Manufacturer'],clientVal['last_seen'],'','','',''))
                    else:
                        orgTable.append(('',clientKey,clientVal['last_seen'],'','','',''))
        
        # Determine column widths
        colWidths = GetColumnWidths(orgTable)
        
        # Print out the table headers
        print('\n')
        for item in range(len(orgTable[0])):
            print(str(orgTable[0][item]).center(colWidths[item]), end='  ')
        print()
        
        # Initialize local variables to track the previous access point's MAC address
        lastAP = 'A'
        
        for row in range(1, len(orgTable)):
            # Print a blank line between networks
            if orgTable[row][0]:
                # Unless they are (probably) eminating from the same piece of hardware
                if not self.__relatedMAC(lastAP,orgTable[row][1]):
                    print()
                lastAP = orgTable[row][1]
            
            for column in range(len(orgTable[0])):
                print("%-*s  " % (colWidths[column],str(orgTable[row][column])), end="")
            print()


    def PrintApInfo(self,sortColumn):
        ''' Prints out AP info, grouped by category indicated by column '''
        ''' 2 == Manufacturer, 4 == Signal Strength, 5 == Encryption, 6 == Channel '''
        
        # Early return if column is invalid
        if not sortColumn in [2,4,5,6]:
            print("\nUnexpected error occurred")
            return
        
        # First line is the table headers
        if not self.ouiResolved:
            sortColumn -= 1
        
        orgTable = []
        
        # Iterate through the APs to build the table
        for key, val in self.masterDict['aps'].items():
            
            # Indicate when an AP's SSID is hidden
            if val['ssid']:
                holdSSID = val['ssid']
            else:
                holdSSID = "Hidden"
            
            # Add the AP to the table
            if self.ouiResolved:
                orgTable.append((holdSSID,key,val['Manufacturer'],val['last_seen'],val['signal'],val['encryption'],val['channel'],len(val['clients']),str(bool(val['wps']))))
            else:
                orgTable.append((holdSSID,key,val['last_seen'],val['signal'],val['encryption'],val['channel'],len(val['clients']),str(bool(val['wps']))))
        
        # Sort the table by selected category
        orgTable.sort(key=lambda i: i[sortColumn],reverse=(sortColumn==(3+self.ouiResolved))) # This reverse statement revereses for Signal Strength only
        
        # Insert the table headers
        if self.ouiResolved:
            orgTable.insert(0,('SSID','MAC','Manufacturer','Last Seen','Signal Strength','Encryption','Channel','Clients','WPS'))
        else:
            orgTable.insert(0,('SSID','MAC','Last Seen','Signal Strength','Encryption','Channel','Clients','WPS'))
        
        # Determine column widths
        colWidths = GetColumnWidths(orgTable)
        
        # Print out the table
        # Headers (centered)
        print('\n')
        for item in range(len(orgTable[0])):
            print(str(orgTable[0][item]).center(colWidths[item]), end='  ')
        print()
        
        # AP info
        for row in range(1, len(orgTable)):
            # Insert a blank line to separate sorted column into groups
            if orgTable[row-1][sortColumn] != orgTable[row][sortColumn]:
                print()
            
            for column in range(len(orgTable[0])):
                print("%-*s  " % (colWidths[column],str(orgTable[row][column])), end="")
            print()


    def PrintManufSummary(self,AP):
        ''' Summarizes manufacturer info '''
        ''' If AP == True, prints out AP info, otherwise prints out Client info '''
        
        # Early return if OUI data hasn't been resolved
        if not self.ouiResolved:
            print('\nManufacturer data not available')
            return
        
        # If it hasn't already been done, summarize the manufacturer data into their respective dictionaries
        if not (self.apManufSummary and self.clientManufSummary):
            
            # Cycle through each access point
            for apVal in self.masterDict['aps'].values():
                try:
                    self.apManufSummary[apVal['Manufacturer']] += 1
                except KeyError:
                    self.apManufSummary[apVal['Manufacturer']] = 1
                
                # If the AP has clients, cycle through those as well
                if apVal['clients']:
                    for clientVal in apVal['clients'].values():
                        try:
                            self.clientManufSummary[clientVal['Manufacturer']] += 1
                        except KeyError:
                            self.clientManufSummary[clientVal['Manufacturer']] = 1
            
            # Include unassociatedClients
            try:
                for client in self.masterDict['unassociatedClients']:
                    try:
                        self.clientManufSummary[client[1]] += 1
                    except KeyError:
                        self.clientManufSummary[client[1]] = 1
            except KeyError:
                pass
        
        # Initialize the necessary local variables
        manufTable = []
        notFound = 0
        width = 0
        
        # Decide which dictionary to use
        if AP:
            useDict = self.apManufSummary
        else:
            useDict = self.clientManufSummary
        
        # Cycle through and build the table
        for manuf, num in useDict.items():
            if manuf != 'Not found':
                manufTable.append((manuf,num))
            else:
                notFound = num
        
        # Sort the table, then add "Not found" to the bottom
        manufTable.sort(key=lambda num: num[1], reverse=True)
        manufTable.append(('Not found',notFound))
        
        # Calculate the needed width for the manufacturer column
        for eachEntry in manufTable:
            if len(eachEntry[0]) > width:
                width = len(eachEntry[0])
        
        # Print out the table
        print("\n")
        print(" %s  Count\n" % "Manufacturer".center(width))
        for eachEntry in manufTable:
            print(" %*s  %d" % (width, eachEntry[0], eachEntry[1]))
        print()


    def PrintSummary(self):
        # Initialize local variables
        numAPs = len(self.masterDict['aps'].keys())
        numWithClients = 0
        # Clients associated with APs will be added later
        totalClients = len(self.masterDict['unassociatedClients']) + len(self.masterDict['outOfRangeClients'])
        ssids = []
        channels = []
        security = {}
        
        # Loop through each access point; gather relavent info
        for key, val in self.masterDict["aps"].items():
            # Collect SSIDs
            if val["ssid"]:
                ssids.append(val["ssid"])
                
            # Tally up clients
            if val["clients"] != "":
                numWithClients += 1
                totalClients += len(val["clients"])
            
            # Build a list of channels used
            channels.append(val["channel"])
            
            # Track encryption standards used
            try:
                security[val["encryption"]] += 1
            except:
                security[val["encryption"]] = 1
        
        # Remove duplicates from the Channel and SSID lists
        channels = set(channels)
        channels = list(channels)
        channels.sort()
        ssids = set(ssids)
        ssids = list(ssids)
        
        # Print findings to output
        print("\nReport Summary:")
        print(f"       Number of Access Points: {numAPs}")
        print(f"        Number of Unique SSIDs: {len(ssids)}")
        print(f"    Access Points with Clients: {numWithClients}")
        print("                 Channels Used: ", end="")
        for eachChannel in channels:
            print("%4d" % eachChannel, end="")
        print("\n            ---- Security Used ----")
        for key, val in security.items():
            print("%36s : %d" % (key, val))
        print(f"Number of Unassociated Clients: {len(self.masterDict['unassociatedClients'])}")
        print(f"       Total Number of Clients: {totalClients}")

    
    def ResolveOUIs(self):
        ''' Cycle through each MAC address and try to determine the manufacturer from the IEEE registered list '''
        print()
                
        # This list allows for looping the download later
        sourceList = [('oui','oui'),('cid','cid'),('iab','iab'),('oui28','mam'),('oui36','oui36')]
        
        # Check to see if the database has already been downloaded
        resolve = False
        if path.exists("./OUI/oui.csv") and path.exists("./OUI/oui36.csv") and path.exists("./OUI/iab.csv"):
            qtext = "OUI Database previously downloaded. Re-download now (Y/n)? "
            resolve = True
        else:
            qtext = "OUI Database not locally saved. Download now (Y/n)? "
            
        while True:
            # Have user confirm download
            submit = input(qtext)
            submit = submit.lower()
            if submit == "y" or submit == "":
                print()
                resolve = True
                print("Retrieving OUI database...")
                
                # Create a directory for the OUI files, if it doesn't already exist
                if not path.isdir('./OUI'):
                    path.os.mkdir('./OUI')
                    
                # Loop through the IEEE sources and download to local files
                for x in range(5):
                    try:
                        request.urlretrieve("http://standards-oui.ieee.org/%s/%s.csv" % sourceList[x], "./OUI/%s.csv" % sourceList[x][1])
                    except:
                        print("An error occurred during download. Check network connection and try again.")
                        resolve = False
                        break
                break
            if submit == "n" or submit == "":
                break
            print('\nPlease enter "y" or "n"')
            
        # Do not proceed if the OUI database isn't available
        if resolve:
            # Files downloaded; cycle and read each one to build the OUI lookup dictionary
            print("Processing info... ", end="")
            for x in range(5):
                with open("./OUI/%s.csv" % sourceList[x][1], "r", encoding='UTF-8') as f:
                    f.readline()
                    line = f.readline()
                    while line:
                        # CSV line format is: Registry,Assignment,Organization Name,Organization Address
                        line = line.split(",")
                        macKey = line[1].upper()
                        manufVal = line[2]
                        
                        # In case the organization name contains a comma, concatenate the pieces together
                        i = 3
                        while manufVal[0] == '"' and manufVal[-1] != '"':
                            manufVal += ","     # Replace the comma that was removed
                            manufVal += line[i]
                            manufVal = manufVal.strip()
                            i += 1
                        manufVal = manufVal.strip('"')
                        
                        # Add the entry to the dictionary and advance to the next line
                        self.ouiLookup[macKey] = manufVal
                        line = f.readline()
                    f.close()
            
            # Dictionary built; now cycle through APs and clients, and determine the manufacturer
            for key, val in self.masterDict['aps'].items():
                val["Manufacturer"] = self.__getOUI(key)
                if val["clients"]:
                    for clientMac, clientDict in val["clients"].items():
                        clientDict["Manufacturer"] = self.__getOUI(clientMac)
            
            # Same thing for unassociated clients
            try:
                for x in range(len(self.masterDict['unassociatedClients'])):
                    # Convert entry to a tuple; [0] == Client MAC, [1] == Manufacturer
                    client = self.masterDict['unassociatedClients'][x]
                    client = (client,self.__getOUI(client))
                    self.masterDict['unassociatedClients'][x] = client
            except KeyError:
                pass
            
            # ...and again for out-of-range clients
            try:
                for clientMAC, apMAC in self.masterDict['outOfRangeClients'].items():
                    # Convert each client value to a dictionary; store the relevant info
                    self.masterDict['outOfRangeClients'][clientMAC] = {
                        'Manufacturer': self.__getOUI(clientMAC),
                        'bssid': apMAC,
                        'apManufacturer': self.__getOUI(apMAC)
                    }
            except KeyError:
                pass
                        
            # Signal other parts of the script to include manufacturer data in analysis
            self.ouiResolved = True
            print("Complete")

    
            
''' ----------------------------------- '''
'''     END OF ParseReconJSON CLASS     '''
''' ----------------------------------- '''

# Supporting functions start here

def GetColumnWidths(table):
    ''' Calculates maximum string lengths for the columns of a table '''
    
    widths = []
    for column in range(len(table[0])):
        widths.append(0)
        for row in range(len(table)):
            if len(str(table[row][column])) > widths[column]:
                widths[column] = len(str(table[row][column]))
    
    return widths


def getUserSelection(maxOption):
    
    while True:
        try:
            sel = input(f'Enter Selection (0-{maxOption}) >> ')
            menuSelection = int(sel)
        except ValueError:
            print (f'Invalid input. Enter a value between 0-{maxOption}.')
            continue
    
        if not menuSelection in range(maxOption + 1):
            print (f'Invalid input. Enter a value between 0 - {maxOption}.')
            continue
    
        return menuSelection


def MainMenu(ReconObj):
    ''' Runs the menu; each option is a function controlled by the supplied ParseReconJSON object '''
    if str(type(ReconObj)) != "<class '__main__.ParseReconJSON'>":
        print("Incorrect input to run menu.")
        return
    
    menuSelection = -1
    
    while menuSelection != 0:

        if menuSelection != -1:
            print()
            s = input('Press Enter to continue...')
        
        # In order to create a dynamic menu that changes depending on available info, the user selection
        # is mapped to a number on the 'options' list which is then used in the if..elif..else chain.
        # i.e. User chooses 9; options[9] == 12; 12 -> Determine hardware manufacturers
        numOptions = 5
        options = [0, 1, 2, 3, 4, 5, 9, 10]
        print("\n========== Recon Data Query Options =========")
        print("| [1]    Print Report Summary")
        print("| [2]    Show AP-Client Associations")
        print("|\n|    -- Access Points -- Sort By --")
        print("| [3]    Signal Strength")
        print("| [4]    Encryption Standard")
        print("| [5]    Radio Channel")
        if ReconObj.ouiResolved:
            print ("| [6]    Hardware Manufacturer")
            options.append(6)
            numOptions += 1
        print("|")
        if ReconObj.ouiResolved:
            numOptions += 1
            print (f"| [{numOptions}]    Client Manufacturer Summary")
            options.append(7)
            numOptions += 1
            print (f"| [{numOptions}]    Access Point Manufacturer Summary")
            options.append(8)
        numOptions += 1
        print(f"| [{numOptions}]    List Out-of-Range Clients")
        numOptions += 1
        print(f"| [{numOptions}]    List Unassociated Clients")
        if not ReconObj.ouiResolved:
            numOptions += 1
            print (f"| [{numOptions}]    Determine Hardware Manufacturers")
            options.append(11)
        print()
        print ("  [0]    Exit\n")
        
        options.sort()
        menuSelection = getUserSelection(numOptions)
        menuSelection = options[menuSelection]
        
        if menuSelection == 1:
            # Print Report Summary
            ReconObj.PrintSummary()
        
        elif menuSelection == 2:
            # Show AP-Client Associations
            ReconObj.PrintAssociations()

        elif menuSelection == 3:
            # AP - Sort by Signal Strength
            ReconObj.PrintApInfo(4)

        elif menuSelection == 4:
            # AP - Sort by Encryption Standard
            ReconObj.PrintApInfo(5)
            
        elif menuSelection == 5:
            # AP - Sort by Radio Channel
            ReconObj.PrintApInfo(6)
            
        elif menuSelection == 6:
            # AP - Sort by Manufacturer
            ReconObj.PrintApInfo(2)
            
        elif menuSelection == 7:
            # Client Manufacturer Summary
            ReconObj.PrintManufSummary(False)
            
        elif menuSelection == 8:
            # Access Point Manufacturer Summary
            ReconObj.PrintManufSummary(True)
        
        elif menuSelection == 9:
            # List Out-of-Range Clients
            ReconObj.ListOutOfRange()
        
        elif menuSelection == 10:
            # List Unassociated Clients
            ReconObj.ListUnassociated()
        
        elif menuSelection == 11:
            # Determine Hardware Manufacturers
            ReconObj.ResolveOUIs()
            
        elif menuSelection == 0:    
            print("Goodbye")
            
        elif menuSelection == -1:
            continue
        
        else:
            print ("unexpected error condition")
            menuSelection = 0    


''' -------------------------- '''
'''  MAIN PROGRAM STARTS HERE  '''
''' -------------------------- '''

# Initialize global variables
filepath = ""

# Get and verify filepath from command line argument, if supplied
if len(argv) > 1:
    filepath = argv[1]
    if not path.isfile(filepath):
        print(f"Invalid file: {filepath}")
        quit()
    filepath = path.abspath(filepath)

while not path.isfile(filepath):
    # Get a file from the user and verify as a valid selection.
    submit = input("Enter a file to analyze: ")
    submit = submit.strip('"')
    if path.exists(submit) and path.isfile(submit):
        filepath = path.abspath(submit)
        break
    else:
        print(f"Invalid selection: {submit}\n")    

# Create a parser object using the supplied file
recon = ParseReconJSON(filepath)

MainMenu(recon)